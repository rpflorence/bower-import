var bower = require('bower');
var path = require('path');
var jf = require('jsonfile');
var fs = require('fs');
var prompt = require('sync-prompt').prompt;
var log = require('./lib/log');

module.exports = function(program) {
  return Object.create(importer).init(program);
};

var importer = exports.importer = {

  init: function(program) {
    this.env = Object.create(program);
    this.run();
    return this;
  },

  run: function() {
    jf.readFile(this.env.config, this.onReadUserConfig.bind(this));
  },

  onReadBower: function(bowerData) {
    var deps = makeArray(flatten(bowerData.dependencies));
    this.env.pkgConfig = deps.filter(this.filterDep.bind(this)).map(this.mapDep.bind(this));
    this.addAppToPackageConfig();
    if (this.env.stdout) {
      process.stdout.write(JSON.stringify(this.env.pkgConfig, null, 2)+'\n');
    } else {
      this.writeConfig();
    }
  },

  onReadUserConfig: function(err, json) {
    if (err) throw new Error(err);
    this.env.userConfig = json;
    json.paths = json.paths || {};
    json.shim = json.shim || {};
    json.packages = json.packages || [];
    json.ignore = json.ignore || [];
    bower.commands.list().on('end', this.onReadBower.bind(this));
  },

  appendNewPackages: function() {
    var config = this.env.userConfig;
    config.packages = config.packages.concat(this.env.pkgConfig);
  },

  getPackageName: function(pkg) {
    return 'string' == typeof pkg ? pkg : pkg.name;
  },

  writeConfig: function() {
    this.appendNewPackages();
    var configPath = this.env.outfile || this.env.config.replace(/\.json/, '.js');
    var src = '// auto-generated by bower-import, edits will be lost\n'+
              'var require = '+JSON.stringify(this.env.userConfig, null, 2)+'\n';
    fs.writeFile(configPath, src, function() {
      log.write('=> generated loader config', configPath);
      jf.writeFile(this.env.config, this.env.userConfig, function(err) {
        if (err) throw new Error(err);
        log.write('=> saved user config', configPath);
      });
    }.bind(this));
  },

  addAppToPackageConfig: function() {
    if (!~this.env.userConfig.packages.map(this.getPackageName).indexOf('app')) {
      this.env.pkgConfig.unshift({name: 'app', location: this.env.app});
    }
  },

  depIsIgnored: function(dep) {
    return ~this.env.userConfig.ignore.indexOf(dep.endpoint.name);
  },


  depIsShimmedAlready: function(dep) {
    var shims = this.env.userConfig.shim;
    return shims && shims[dep.endpoint.name];
  },

  depIsRegisteredAlready: function(dep) {
    var packages = this.env.userConfig.packages;
    if (!packages) return false;
    return ~packages.map(this.getPackageName).indexOf(dep.endpoint.name);
  },

  depHasNoMainScript: function(dep) {
    if (!dep.pkgMeta.main) {
      log.warn('skipping '+dep.endpoint.name+', no main script configured');
      return true;
    }
    return false;
  },

  getAmdSupport: function(dep) {
    var formats = dep.pkgMeta.moduleFormats;
    var amd = formats && ~formats.indexOf('amd');
    if (amd) { return true; }
    var response = prompt(dep.endpoint.name+' does not appear to support amd, does it?: (y/n): ');
    if (response == 'y') { return true; }
    return this.promptToShim(dep);
  },

  promptToShim: function(dep) {
    var name = dep.endpoint.name;
    var shim = prompt('would you like to shim '+name+'? (y/n): ');
    if (shim != 'y') {
      this.env.userConfig.ignore.push(dep.endpoint.name);
      return false;
    }
    var config = {};
    if (dep.dependencies) {
      config.deps = Object.keys(dep.dependencies);
    }
    config.exports = prompt('what global does '+name+' export?: ').trim();
    this.env.userConfig.shim[name] = config;
    return true;
  },

  filterDep: function(dep) {
    if (dep.endpoint.name == 'requirejs') { return false; }
    if (this.depIsIgnored(dep)) { return false; }
    if (this.depIsShimmedAlready(dep)) { return false; }
    if (this.depIsRegisteredAlready(dep)) { return false; }
    if (this.depHasNoMainScript(dep)) { return false; }
    return this.getAmdSupport(dep);
  },

  mapDep: function(dep) {
    var name = dep.endpoint.name;
    var main = this.getMain(dep).replace(/\.js$/, '');
    if (main == 'main') {
      return name;
    }
    return {
      name: name,
      main: main
    };
  },

  getMain: function(dep) {
    if ('string' == typeof dep.pkgMeta.main) {
      return dep.pkgMeta.main;
    } else {
      // TODO: prompt for which one to use
      return dep.pkgMeta.main[0];
    }
  }

};

function flatten(deps, list) {
  var dep;
  list = list || {};
  for (var name in deps) {
    dep = deps[name];
    list[name] = dep;
    if (dep.dependencies) {
      flatten(dep.dependencies, list);
    }
  }
  return list;
}

function makeArray(obj) {
  var arr = [];
  for (var key in obj) {
    arr.push(obj[key]);
  }
  return arr;
}

